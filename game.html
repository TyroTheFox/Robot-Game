<!DOCTYPE HTML>
<html>
	<head>
		<title>pixi.js example 1</title>
		<script src="pixi.js"></script>
	</head>
	<body>
		<script>
			var renderer = PIXI.autoDetectRenderer(1200, 600, { antialias: true });
			document.body.appendChild(renderer.view);

			// create the root of the scene graph
			var stage = new PIXI.Container();

			stage.interactive = true;

			var deck = new Array();
			var hand = new Array();
			var style = {
			    fill : '#FF0000'
			};

			var deckSize = 20;

			var handX = 370;
			var handY = 370;

			var deckPos = 0;
			var handSize = 6;
			var cardNo = 0;

			var end = handSize;
			var submitted = new Array();
			var discard = new Array();

			for (var i = 0; i < deckSize; i++)
			{
				createCard(handX, 370);
			}	

			var testCore = new PIXI.Graphics();
			// set a fill and a line style again and draw a rectangle
			testCore.lineStyle(2, 0xFF0000, 1);
			testCore.beginFill(0xFFFFFF, 1);
			testCore.drawRoundedRect(50, 100, 200, 50);
			testCore.endFill();
			// enable the bunny to be interactive... this will allow it to respond to mouse and touch events
			testCore.interactive = true;
			// this button mode will mean the hand cursor appears when you roll over the bunny with your mouse
			testCore.buttonMode = true;
			testCore.on('mouseup', loadCore);
			testCore.on('touchend', loadCore);
			var coreIcon = new PIXI.Text('Core', style);
			coreIcon.x = testCore.graphicsData[0].shape.x + 20;
			coreIcon.y = testCore.graphicsData[0].shape.y + 20;
			stage.addChild(testCore);
			stage.addChild(coreIcon);

			var forwardBtn = new PIXI.Graphics();
			// set a fill and a line style again and draw a rectangle
			forwardBtn.lineStyle(2, 0x00FF00, 1);
			forwardBtn.beginFill(0xFFFFFF, 1);
			forwardBtn.drawRoundedRect(1100, 370, 50, 200);
			forwardBtn.endFill();
			// enable the bunny to be interactive... this will allow it to respond to mouse and touch events
			forwardBtn.interactive = true;
			// this button mode will mean the hand cursor appears when you roll over the bunny with your mouse
			forwardBtn.buttonMode = true;
			forwardBtn.on('mouseup', scrollHandForward);
			forwardBtn.on('touchend', scrollHandForward);
			var forIcon = new PIXI.Text('>', style);
			forIcon.x = forwardBtn.graphicsData[0].shape.x + 20;
			forIcon.y = forwardBtn.graphicsData[0].shape.y + 20;
			stage.addChild(forwardBtn);
			stage.addChild(forIcon);

			var backBtn = new PIXI.Graphics();
			// set a fill and a line style again and draw a rectangle
			backBtn.lineStyle(2, 0x0000FF, 1);
			backBtn.beginFill(0xFFFFFF, 1);
			backBtn.drawRoundedRect(700, 370, 50, 200);
			backBtn.endFill();
			// enable the bunny to be interactive... this will alvlow it to respond to mouse and touch events
			backBtn.interactive = true;
			// this button mode will mean the hand cursor appears when you roll over the bunny with your mouse
			backBtn.buttonMode = true;
			backBtn.on('mouseup', scrollHandBack);
			backBtn.on('touchend', scrollHandBack);
			var backIcon = new PIXI.Text('<', style);
			backIcon.x = backBtn.graphicsData[0].shape.x + 15;
			backIcon.y = backBtn.graphicsData[0].shape.y + 20;
			stage.addChild(backBtn);
			stage.addChild(backIcon);

			/*var submitBtn = new PIXI.Graphics();
			// set a fill and a line style again and draw a rectangle
			submitBtn.lineStyle(2, 0x0000FF, 1);
			submitBtn.beginFill(0xFFFFFF, 1);
			submitBtn.drawRoundedRect(720, 250, 400, 50);
			submitBtn.endFill();
			// enable the bunny to be interactive... this will alvlow it to respond to mouse and touch events
			submitBtn.interactive = true;
			// this button mode will mean the hand cursor appears when you roll over the bunny with your mouse
			submitBtn.buttonMode = true;
			submitBtn.on('mouseup', submitHand);
			submitBtn.on('touchend', submitHand);
			var submitText = new PIXI.Text('Submit', style);
			submitText.x = submitBtn.graphicsData[0].shape.x + 15;
			submitText.y = submitBtn.graphicsData[0].shape.y + 20;
			stage.addChild(submitBtn);
			stage.addChild(submitText);*/

			function createCard(x, y){
				var testCard = new PIXI.Graphics();
				// set a fill and a line style again and draw a rectangle
				testCard.lineStyle(2, 0x0000FF, 1);
				testCard.beginFill(0xFFFFFF, 1);
				testCard.drawRoundedRect(x, y, 150, 200);
				testCard.endFill();
				// enable the bunny to be interactive... this will allow it to respond to mouse and touch events
			    testCard.interactive = true;
			    // this button mode will mean the hand cursor appears when you roll over the bunny with your mouse
			    testCard.buttonMode = true;
			    testCard.on('mouseup', selectCard);
			    testCard.on('touchend', selectCard);
			    testCard.selected = false;
			    var basicText = new PIXI.Text(cardNo, style);
			    testCard.priority = cardNo;
				basicText.x = testCard.graphicsData[0].shape.x + 20;
				basicText.y = testCard.graphicsData[0].shape.y + 20;
				cardNo++;
				testCard.text = basicText;
				deck.push(testCard);
			}

			var a = 1;
			for (var i = deckPos; i < handSize; i++)
			{
				deck[i].position.x = handX + (a * 30);
				deck[i].text.position.x = deck[i].position.x + handX + 10;
				a++;
				stage.addChild(deck[i]);
				stage.addChild(deck[i].text)
			}

			// run the render loop
			animate();

			function animate() {
			    renderer.render(stage);
			    requestAnimationFrame( animate );
			}

			function selectCard(){
				if(this.selected == true){
					this.position.y = this.position.y + 50;
					this.text.position.y = this.text.position.y + 50;
				}else{
					this.position.y = this.position.y - 50;
					this.text.position.y = this.text.position.y - 50;
					this.selected = true;
				}
			}

			function scrollHandForward(){
				removeCards(0, deck.length);
				if((deckPos + handSize) <= deck.length){
					deckPos = (deckPos + handSize);
					scrollCards((deckPos - handSize), deckPos, 1);
				}else{
					scrollCards(deckPos, deck.length, 1);
					deckPos = 0;
				}
				animate();
			}

			function scrollHandBack(){
				removeCards(0, deck.length);
				if((deckPos - handSize) >= 0){
					deckPos = (deckPos - handSize);
					scrollCards(deckPos, (deckPos + handSize), 1);
				}else{
					scrollCards(((deck.length/handSize).toFixed(0))*handSize, deck.length,1);
					deckPos = ((deck.length/handSize).toFixed(0))*handSize;
				}
				animate();
			}

			function removeCards(a, end){
				if(a < end){
					stage.removeChild(deck[a]);
					stage.removeChild(deck[a].text);
					a++;
					removeCards(a, end);
				}
				return;
			}

			function scrollCards(a, end, xOff){
				if(a >= end){
				}else{
					deck[a].position.x = handX + (xOff * 30);
					deck[a].text.position.x = deck[a].position.x + handX + 10;
					stage.addChild(deck[a]);
					stage.addChild(deck[a].text);
					a++;
					xOff++;
					scrollCards(a, end, xOff);
				}
			}

			function submitHand(){
				var submittedHand = 'Submitted: ';
				var discardPile = 'Discard: ';
				a = 0;
				for (var i = 0; i < deck.length; i++)
				{ 
					if(deck[i].selected){
						submittedHand += ' ' + deck[i].text._text;
						submitted[a] = deck[i];
						discard[a] = deck.splice(i, 1)[0];
						discardPile += discard[a].text._text;
						a++;
					}
				}
				var submitText = new PIXI.Text(submittedHand, style);
				submitText.x = 20;
				submitText.y = 20;
				stage.addChild(submitText);
				var discardText = new PIXI.Text(discardPile, style);
				discardText.x = 20;
				discardText.y = 1000;
				stage.addChild(discardText);
				animate();
			}

			function loadCore(){
				submitHand();
				testCore.chamber = submitted;
				loadedCore = 'Core: ';
				var sumPriority = 0;
				for (var i = 0; i < testCore.chamber.length; i++)
				{ 
					loadedCore += ' ' + testCore.chamber[i].text._text;
					sumPriority += testCore.chamber[i].priority;
				}
				var submitText = new PIXI.Text(loadedCore, style);
				submitText.x = 20;
				submitText.y = 180;
				stage.addChild(submitText);
				var submitText = new PIXI.Text("Sum Priority: " + sumPriority, style);
				submitText.x = 20;
				submitText.y = 220;
				stage.addChild(submitText);
				animate();
			}

			/*function scrollCardsBackwards(a, end, xOff){
				if(a >= end){
					console.log('Move backward ' + a + ' End ' + end);
				}else{
					console.log('Card ' + a + ' End ' + end);
					deck[a].position.x = handX + (xOff * 30);
					deck[a].text.position.x = deck[a].position.x + handX + 10;
					stage.addChild(deck[a]);
					stage.addChild(deck[a].text);
					a++;
					xOff++;
					scrollCardsBackwards(a, end, xOff);
				}
			}*/

			/*function addCardsForward(){
				end = deckPos + handSize;
				alert(end + ' ' + deckPos);
				if(end > deck.length){
					var a = 1;
					dfor (var i = deckPos; i > deck.length; i++)
					{
						alert('Over'+i);
						deck[i].position.x = handX + (a * 30);
						deck[i].text.position.x = deck[i].position.x + handX + 10;
						a++;
						stage.addChild(deck[i]);
						stage.addChil(deck[i].text);
					}
					deckPos = 0;
					end = handSize;
				}else{
					var a = 1;
					for (var i = deckPos; i > end; i++)
					{
						alert('Under'+i);
						deck[i].position.x = handX + (a * 30);
						deck[i].text.position.x = deck[i].position.x + handX + 10;
						a++;
						stage.addChild(deck[i]);
						stage.addChild(deck[i].text);
					}
				}
			}

			function addCardsBack(){
				if(deckPos + handSize < deck.length){
					overflow = end - deck.length;
					deckPos = 0;
					end = handSize;
				}
				var a = 1;
				for (var i = end; i > deckPos; i++)
				{
					deck[i].position.x = handX + (a * 30);
					deck[i].text.position.x = deck[i].position.x + handX + 10;
					a++;
					stage.addChild(deck[i]);
					stage.addChild(deck[i].text);
				}
			}*/
		</script>
	</body>
</html>